#+TITLE: audio2score: Audio → MIDI → MusicXML → PDF pipeline
#+AUTHOR: YAMASHITA, Takao
#+LANGUAGE: ja
#+OPTIONS: toc:t num:t
#+PROPERTY: header-args :noweb no-export :mkdirp yes

* プロジェクト概要

本プロジェクトは、*音源ファイルから自動的に楽譜を生成する再現可能なパイプライン* を構築することを目的としています。

- 入力: 単一のオーディオファイル（任意形式）
  - 例: =input.wav=, =input.mp3=, =input.flac=, =input.m4a=, =input.aifc= など
  - Makefile で *ffmpeg により WAV (=build/<name>.wav=) に変換*
  - audio2score.py 側で *さらに normalized WAV (=<name>.normalized.wav=) に正規化*
- 出力:
  - 正規化済み WAV (=<name>.normalized.wav=)
  - 自動採譜された MIDI (=build/<name>.normalized_basic_pitch.mid=)
  - MIDI から生成した MusicXML (=build/<name>.normalized_basic_pitch.musicxml=)
  - MusicXML から生成した PDF (=build/<name>.normalized_basic_pitch.pdf=; MuseScore が安定動作した場合)

中核は Python スクリプト =audio2score.py= で、Org Babel の =:tangle= によって本 README.org から生成されます。
ビルド・実行は Makefile 経由で行い、*macOS + pyenv 3.10 系* を前提とします。

* 環境と依存関係

** OS / ランタイム

- OS: macOS
- Python: pyenv による 3.10 系（例: 3.10.14）
- 仮想環境: =python -m venv .venv=

** 外部コマンド

- *ffmpeg*
  - 任意形式（aifc, mp3 等）→ WAV (=build/<name>.wav=) への変換に使用
  - 例: =brew install ffmpeg=
- *MuseScore 4*（GUI + CLI）
  - バイナリ: =/Applications/MuseScore 4.app/Contents/MacOS/mscore=
  - CLI コマンド名: =mscore=
  - PATH に =mscore= を通すための例:

    #+begin_src sh
      ln -s "/Applications/MuseScore 4.app/Contents/MacOS/mscore" \
        /opt/homebrew/bin/mscore
    #+end_src

** Python パッケージと requirements.txt

Python パッケージは =requirements.txt= で管理し、Org から =:tangle= で生成します。

#+begin_src text :tangle requirements.txt
  basic-pitch
  music21
  librosa
  soundfile
#+end_src

- =basic-pitch= :: Audio → MIDI（自動採譜）用。Python 3.10 系での動作を前提。
- =music21= :: MIDI → MusicXML のフォールバック用。
- =librosa= :: normalized WAV 生成のためのオーディオ前処理。
- =soundfile= :: normalized WAV の書き出し。

*バージョン固定について*

ここではシンプルにパッケージ名のみ記載しています。
特定環境での完全再現性を確保したい場合は

1. 仮想環境を構築してこの requirements.txt でインストール
2. 動作確認後に =pip freeze > requirements.txt= でロックファイル化

という運用を推奨します。

* ファイル構成

想定する最小構成は以下の通りです。

- =README.org= :: 本ファイル。Org Babel から =audio2score.py= / =Makefile= / =requirements.txt= を =:tangle= で生成。
- =audio2score.py= :: 音源 → MIDI → MusicXML → PDF のメインスクリプト（Org から生成）。
- =Makefile= :: セットアップおよび実行用ターゲット（Org から生成）。
- =requirements.txt= :: Python 依存パッケージ一覧（Org から生成）。
- =build/= :: 生成物出力ディレクトリ。
  - =build/<name>.wav= :: ffmpeg による中間 WAV
  - =build/<name>.normalized_basic_pitch.mid= :: Basic Pitch による MIDI
  - =build/<name>.normalized_basic_pitch.musicxml= :: MIDI から生成した MusicXML
  - =build/<name>.normalized_basic_pitch.pdf= :: MusicXML から生成した PDF

元のオーディオファイル（aifc など）は、任意の場所 (=../env/input/…= 等) に置いて構いません。

* 処理パイプラインの概要

パイプラインは 5 ステージに分割されます。

1. *フォーマット変換（ffmpeg）*
   - 任意形式のオーディオ (=INPUT=) を WAV (=build/<name>.wav=) に変換。
   - 例:
     - =../env/input/どこにいるのだろう.aifc=
     - → =build/どこにいるのだろう.wav=

2. *前処理（preprocess_audio）*
   - audio2score.py 内で WAV を librosa で読み込み
     - モノラル化（=mono=True=）
     - リサンプリング（既定: 22050 Hz）
     - ピーク正規化（最大振幅 = 0.95）
   - 出力: =build/どこにいるのだろう.normalized.wav=

3. *自動採譜（run_basic_pitch）*
   - Basic Pitch で normalized WAV から MIDI を生成。
   - 出力: =build/どこにいるのだろう.normalized_basic_pitch.mid=
   - Basic Pitch は同名ファイルが存在すると OSError を投げてスキップするため、
     - audio2score.py 側で実行前に =*_basic_pitch.*= を削除してから実行。

4. *MIDI → MusicXML*
   - 優先: MuseScore CLI (=mscore=) に MIDI を渡して MusicXML を生成。
   - フォールバック: MuseScore が失敗した場合は music21 で MIDI をパースし、
     =Score.write("musicxml")= によって MusicXML を生成。

5. *MusicXML → PDF*
   - MuseScore CLI による MusicXML→PDF 変換。
   - MuseScore のクラッシュ（SIGSEGV 等）の場合は WARNING を出しつつ PDF を諦め、
     MIDI / MusicXML は保持する。

* コマンド・インタフェース

** audio2score.py のエントリポイント

スクリプトの CLI インタフェースは以下の通りです。

- 必須引数
  - =audio=: *WAV ファイル* を渡すことを前提とする。
    - Makefile で =build/<name>.wav= を作ってから、このパスを渡す。

- 主なオプション
  - =--output-dir OUTDIR=
    - 生成物を出力するディレクトリ（既定: =build=）
  - =--musescore-cmd CMD=
    - MuseScore CLI コマンド（既定: =mscore=）
  - =--no-pdf=
    - PDF を生成せず、*MIDI / MusicXML のみ* 生成する。
  - =--score-only=
    - *Audio → MIDI（Basic Pitch）をスキップ* し、
      既に存在する =build/<name>.normalized_basic_pitch.mid= を再利用して
      MusicXML / PDF のみ生成する。

** 代表的な利用パターン（Makefile 経由）

1. *フルパイプライン（任意形式 → WAV → MIDI → MusicXML → PDF）*

   #+begin_src sh
     make score-full INPUT="../env/input/どこにいるのだろう.aifc"
   #+end_src

   これにより:

   - =build/どこにいるのだろう.wav=（ffmpeg）
   - =build/どこにいるのだろう.normalized.wav=（audio2score.py）
   - =build/どこにいるのだろう.normalized_basic_pitch.mid=
   - =build/どこにいるのだろう.normalized_basic_pitch.musicxml=
   - =build/どこにいるのだろう.normalized_basic_pitch.pdf=（MuseScore が安定なら）

   が生成されます。

2. *既に生成した normalized MIDI から MusicXML / PDF のみ再生成*

   #+begin_src sh
     make score INPUT="../env/input/どこにいるのだろう.aifc"
   #+end_src

   - あらかじめ =score-full= 等で
     =build/どこにいるのだろう.normalized_basic_pitch.mid= が存在している前提。
   - ffmpeg により再度 =build/どこにいるのだろう.wav= を作り、
     audio2score.py に渡して =--score-only= モードで
     MusicXML / PDF のみを生成・更新します。

3. *PDF を生成せず、MusicXML までで止める*

   #+begin_src sh
     make score-no-pdf INPUT="../env/input/どこにいるのだろう.aifc"
   #+end_src

* Makefile による再現性の確保

以下の Makefile は、Org から =:tangle= によって生成されます。
Python バージョンを *pyenv 3.10 系* に固定し、ffmpeg によるフォーマット変換も一括で管理します。

** Makefile（tangle 対象）

#+begin_src makefile :tangle Makefile
  VENV := .venv

  # pyenv 3.10 系を明示的に指定（環境に合わせて書き換え）
  PYTHON_BASE ?= ~/.pyenv/versions/3.10.14/bin/python

  PYTHON := $(VENV)/bin/python
  PIP := $(VENV)/bin/pip

  # INPUT:
  # - 任意のオーディオファイル（aifc/wav/mp3/flac/m4a 等）
  # - 例: ../env/input/どこにいるのだろう.aifc
  INPUT ?= input.wav

  OUTDIR ?= build

  # ファイル名部分だけ抜き出して WAV を生成
  BASENAME := $(basename $(notdir $(INPUT)))
  WAV_INPUT := $(OUTDIR)/$(BASENAME).wav

  # macOS / MuseScore 用（環境に応じて上書き可）
  MUSESCORE_CMD ?= mscore

  RUN_ARGS ?=

  .PHONY: all setup score score-full score-existing score-no-pdf run clean

  all: setup

  $(VENV)/bin/activate: requirements.txt
  	$(PYTHON_BASE) -m venv $(VENV)
  	$(PIP) install --upgrade pip
  	$(PIP) install -r requirements.txt
  	touch $(VENV)/bin/activate

  setup: $(VENV)/bin/activate

  $(OUTDIR):
  	mkdir -p $(OUTDIR)

  # 任意形式 → WAV への変換ステップ（ffmpeg 必須）
  # 例:
  #   INPUT = ../env/input/どこにいるのだろう.aifc
  #   → WAV_INPUT = build/どこにいるのだろう.wav
  $(WAV_INPUT): $(OUTDIR) $(INPUT)
  	ffmpeg -y -i "$(INPUT)" -ac 1 -ar 44100 "$(WAV_INPUT)"

  # ★ score = フルパイプライン（任意形式 → WAV → MIDI → MusicXML → PDF）
  # 例: make score INPUT=../env/input/どこにいるのだろう.aifc
  score: score-full

  # 実体: フルパイプライン
  score-full: setup $(WAV_INPUT)
  	$(PYTHON) audio2score.py $(WAV_INPUT) \
  		--output-dir $(OUTDIR) \
  		--musescore-cmd $(MUSESCORE_CMD)

  # 既存の normalized MIDI を再利用し、MusicXML / PDF のみ生成
  # 例: make score-existing INPUT=../env/input/どこにいるのだろう.aifc
  score-existing: setup $(WAV_INPUT)
  	$(PYTHON) audio2score.py $(WAV_INPUT) \
  		--output-dir $(OUTDIR) \
  		--musescore-cmd $(MUSESCORE_CMD) \
  		--score-only

  # PDF は作らず、MIDI / MusicXML まで
  # 例: make score-no-pdf INPUT=../env/input/どこにいるのだろう.aifc
  score-no-pdf: setup $(WAV_INPUT)
  	$(PYTHON) audio2score.py $(WAV_INPUT) \
  		--output-dir $(OUTDIR) \
  		--musescore-cmd $(MUSESCORE_CMD) \
  		--no-pdf

  # 任意の追加引数を渡したいときに使う汎用ターゲット
  # 例: make run INPUT=../env/input/foo.mp3 RUN_ARGS="--no-pdf"
  run: setup $(WAV_INPUT)
  	$(PYTHON) audio2score.py $(WAV_INPUT) \
  		--output-dir $(OUTDIR) \
  		--musescore-cmd $(MUSESCORE_CMD) \
  		$(RUN_ARGS)

  clean:
  	rm -rf $(VENV) $(OUTDIR) *.normalized.wav
#+end_src

* audio2score.py 実装（Basic Pitch 遅延 import 版）

以下が audio2score.py の完全な実装です。
Basic Pitch の import は *run_basic_pitch 内で遅延実行* しており、=--score-only= モードでは basic_pitch に一切触れません。

** audio2score.py（tangle 対象）

#+begin_src python :tangle audio2score.py
  #!/usr/bin/env python
  import argparse
  import pathlib
  import subprocess
  import sys
  from typing import Optional

  import librosa
  import numpy as np
  import soundfile as sf
  from music21 import converter


  def preprocess_audio(input_path: pathlib.Path, target_sr: int = 22050) -> pathlib.Path:
      """Load audio, convert to mono, resample, normalize, and write to WAV.

      - ステレオ → モノラル
      - サンプリングレートを target_sr に統一
      - 振幅正規化（ピーク 0.95）
      """
      y, sr = librosa.load(str(input_path), sr=target_sr, mono=True)
      if y.size == 0:
          raise ValueError(f"Empty audio after loading: {input_path}")
      peak = np.max(np.abs(y))
      if peak > 0:
          y = 0.95 * y / peak
      out_path = input_path.with_suffix(".normalized.wav")
      sf.write(str(out_path), y, target_sr)
      return out_path


  def run_basic_pitch(
      wav_path: pathlib.Path,
      output_dir: pathlib.Path,
  ) -> pathlib.Path:
      """Run Basic Pitch and return path to generated MIDI file.

      Basic Pitch は、入力音源と同じベース名にサフィックスを付けた .mid を生成する。
      例: build/foo.normalized.wav → build/foo.normalized_basic_pitch.mid
      """
      # ★ ここで初めて Basic Pitch を import（--score-only ではこの関数自体が呼ばれない）
      try:
          from basic_pitch.inference import predict_and_save
          from basic_pitch import ICASSP_2022_MODEL_PATH
      except Exception as exc:  # ImportError でも NameError でもまとめて捕捉
          raise RuntimeError(
              "Basic Pitch (basic_pitch) をインポートできなかったため、"
              "Audio→MIDI ステップを実行できません。\n"
              "・Audio→MIDI が不要な場合は --score-only を使ってください。\n"
              "・フルパイプラインを使う場合は basic_pitch のインストール／バージョンを確認してください。"
          ) from exc

      output_dir.mkdir(parents=True, exist_ok=True)

      stem = wav_path.stem  # 例: "foo.normalized"

      # Basic Pitch が生成する既存ファイルがあると OSError を投げてスキップするので、
      # 実行前に掃除しておく。
      for ext in ("mid", "npz", "csv", "wav"):
          p = output_dir / f"{stem}_basic_pitch.{ext}"
          if p.exists():
              p.unlink()

      # Basic Pitch 実行
      predict_and_save(
          audio_path_list=[str(wav_path)],
          output_directory=str(output_dir),
          save_midi=True,
          sonify_midi=False,
          save_model_outputs=False,
          save_notes=False,  # ノート CSV は使わない
          model_or_model_path=ICASSP_2022_MODEL_PATH,
      )

      # 出力された .mid を探す（通常は <stem>_basic_pitch.mid）
      preferred = output_dir / f"{stem}_basic_pitch.mid"
      if preferred.exists():
          midi_path = preferred
      else:
          candidates = sorted(output_dir.glob(f"{stem}*.mid"))
          if not candidates:
              raise FileNotFoundError(
                  f"Expected MIDI file for {wav_path} not found under {output_dir}. "
                  f"(tried '{preferred.name}' and pattern '{stem}*.mid')"
              )
          midi_path = candidates[0]

      return midi_path


  def run_musescore_convert(
      input_path: pathlib.Path,
      output_path: pathlib.Path,
      musescore_cmd: str,
  ) -> bool:
      """汎用 MuseScore CLI ラッパー: 1 ファイル変換を行う。

      - 成功: True を返す
      - 失敗: WARNING を表示して False を返す
      """
      cmd = [musescore_cmd, "-o", str(output_path), str(input_path)]
      print(f"[INFO] Running MuseScore CLI: {' '.join(cmd)}", file=sys.stderr)
      try:
          subprocess.run(cmd, check=True)
      except FileNotFoundError as exc:
          print(
              f"[WARNING] MuseScore command '{musescore_cmd}' not found; "
              f"skip conversion {input_path} → {output_path}. ({exc})",
              file=sys.stderr,
          )
          return False
      except subprocess.CalledProcessError as exc:
          # SIGSEGV を含む MuseScore 側のクラッシュもここに入る
          print(
              f"[WARNING] MuseScore CLI failed (exit={exc.returncode}) "
              f"when converting {input_path} → {output_path}; skip this conversion.",
              file=sys.stderr,
          )
          return False
      return True


  def midi_to_musicxml(
      midi_path: pathlib.Path,
      musicxml_path: pathlib.Path,
      musescore_cmd: str,
  ) -> pathlib.Path:
      """MIDI → MusicXML を生成する。

      優先:
        1. MuseScore CLI に MIDI を直接渡して MusicXML を生成
        2. 失敗した場合は music21 にフォールバックして MusicXML を生成
      """
      # 1. まず mscore に MIDI を渡す
      if run_musescore_convert(midi_path, musicxml_path, musescore_cmd):
          return musicxml_path

      # 2. ダメなら music21 でフォールバック
      print(
          "[INFO] Falling back to music21 for MIDI → MusicXML conversion.",
          file=sys.stderr,
      )
      score = converter.parse(str(midi_path))
      score.write("musicxml", fp=str(musicxml_path))
      return musicxml_path


  def musicxml_to_pdf(
      musicxml_path: pathlib.Path,
      pdf_path: pathlib.Path,
      musescore_cmd: str,
  ) -> Optional[pathlib.Path]:
      """MusicXML → PDF を MuseScore CLI で行う。

      - 失敗してもパイプライン全体は止めず、None を返すだけ。
      """
      ok = run_musescore_convert(musicxml_path, pdf_path, musescore_cmd)
      if not ok:
          return None
      return pdf_path


  def main(argv: Optional[list[str]] = None) -> int:
      parser = argparse.ArgumentParser(
          description=(
              "Audio → MIDI → MusicXML → PDF pipeline using Basic Pitch, music21, and MuseScore.\n"
              "通常:\n"
              "  audio2score.py build/foo.wav --output-dir build\n"
              "既存の normalized MIDI (build/foo.normalized_basic_pitch.mid) から "
              "MusicXML / PDF だけ作る:\n"
              "  audio2score.py build/foo.wav --output-dir build --score-only\n"
          )
      )
      parser.add_argument("audio", help="Input WAV file (produced by ffmpeg etc.)")
      parser.add_argument(
          "--backend",
          default="basic-pitch",
          choices=["basic-pitch"],
          help="Transcription backend (currently only 'basic-pitch').",
      )
      parser.add_argument(
          "--output-dir",
          type=str,
          default="build",
          help="Directory where MIDI / MusicXML / PDF will be written.",
      )
      parser.add_argument(
          "--musescore-cmd",
          type=str,
          default="mscore",
          help="MuseScore CLI command (e.g., 'mscore', 'musescore4').",
      )
      parser.add_argument(
          "--no-pdf",
          action="store_true",
          help="Do not generate PDF (only MIDI and MusicXML).",
      )
      parser.add_argument(
          "--score-only",
          action="store_true",
          help=(
              "既に Basic Pitch によって生成された normalized MIDI "
              "（build/<name>.normalized_basic_pitch.mid）を再利用し、"
              "MusicXML / PDF だけを生成する。"
              "Audio → MIDI 推論は行わない。"
          ),
      )
      args = parser.parse_args(argv)

      input_path = pathlib.Path(args.audio).expanduser().resolve()
      if not input_path.exists():
          raise SystemExit(f"Input audio not found: {input_path}")

      output_dir = pathlib.Path(args.output_dir).expanduser().resolve()
      output_dir.mkdir(parents=True, exist_ok=True)

      normalized: Optional[pathlib.Path] = None
      midi_path: pathlib.Path

      if args.score_only:
          # Audio → MIDI は既に完了している前提。
          # build/foo.wav → build/foo.normalized.wav → build/foo.normalized_basic_pitch.mid
          normalized = input_path.with_suffix(".normalized.wav")
          stem = normalized.stem  # 例: "foo.normalized"
          candidate = output_dir / f"{stem}_basic_pitch.mid"
          if not candidate.exists():
              raise SystemExit(
                  f"Expected normalized MIDI not found: {candidate}\n"
                  "先に full パイプラインで normalized MIDI を生成してください。\n"
                  "例: audio2score.py build/foo.wav --output-dir build"
              )
          midi_path = candidate
      else:
          # 1. 前処理 (Audio WAV → normalized WAV)
          normalized = preprocess_audio(input_path)
          # 2. Audio → MIDI (Basic Pitch)
          midi_path = run_basic_pitch(normalized, output_dir)

      # 3. MIDI → MusicXML（優先: MuseScore / フォールバック: music21）
      musicxml_path = output_dir / f"{midi_path.stem}.musicxml"
      midi_to_musicxml(midi_path, musicxml_path, musescore_cmd=args.musescore_cmd)

      # 4. MusicXML → PDF（MuseScore、失敗したらスキップ）
      pdf_path: Optional[pathlib.Path] = None
      if not args.no_pdf:
          pdf_path = musicxml_to_pdf(
              musicxml_path,
              output_dir / f"{midi_path.stem}.pdf",
              musescore_cmd=args.musescore_cmd,
          )

      print("=== Audio to score conversion completed ===")
      print(f"Input audio : {input_path}")
      if normalized is not None:
          print(f"Normalized  : {normalized}")
      print(f"MIDI        : {midi_path}")
      print(f"MusicXML    : {musicxml_path}")
      if pdf_path is not None:
          print(f"PDF         : {pdf_path}")
      else:
          print("PDF         : (not generated)")

      return 0


  if __name__ == "__main__":
      raise SystemExit(main())
#+end_src

* 設計上の注意点と制約

- Basic Pitch
  - Basic Pitch 自体は、Python 3.10 / macOS での利用が公式にサポートされています。
  - モデル backend（TFLite / ONNX / TensorFlow）は環境に応じて自動選択されますが、
    本パイプラインではデフォルト構成で動作することを前提としています。
- MuseScore CLI
  - macOS + MuseScore 4.x の組み合わせでは、Export（PDF / オーディオ）で SIGSEGV を含むクラッシュ報告が存在します。
  - 本スクリプトでは *MuseScore 側の失敗でパイプライン全体が止まらない* ように設計し、
    - MIDI / MusicXML までの生成を *必ず* 成果物として確保
    - PDF 生成はベストエフォートとして WARNING で握りつぶす
- 精度について
  - 採譜精度は Basic Pitch モデルと前処理条件に依存し、*100% の浄書結果は保証されません*。
  - 実務利用では、生成された MusicXML / PDF を楽譜ソフト（MuseScore, Dorico, Finale 等）で開き、
    人手での微修正を前提とすることを想定しています。
